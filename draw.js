// Generated by CoffeeScript 1.3.3
(function() {
  var $, activeTool, comparePix, drawing, drop;

  $ = function(id) {
    return document.getElementById(id);
  };

  drawing = false;

  drop = false;

  window.initCanvas = function() {
    var canvas, context;
    window.tool = "pencil";
    canvas = $("draw");
    context = canvas.getContext("2d");
    canvas.addEventListener("mouseover", function(e) {
      return document.body.style.cursor = "crosshair";
    });
    canvas.addEventListener("mouseout", function(e) {
      return document.body.style.cursor = "default";
    });
    canvas.addEventListener("mousedown", function(e) {
      return activeTool(e);
    });
    canvas.addEventListener("mousemove", function(e) {
      return activeTool(e);
    });
    return canvas.addEventListener("mouseup", function(e) {
      return activeTool(e);
    });
  };

  activeTool = function(e) {
    var canvas, color, color_select, context, coord, data, fillColor, i, leftPos, originalPix, originalPos, paintPos, pixel, pixelStack, pixels, px, py, rightPos, scanPos, width, x, y, _i, _j;
    canvas = $("draw");
    context = canvas.getContext("2d");
    width = 3;
    color_select = $("color");
    color = "#" + color_select.value;
    x = e.offsetX;
    y = e.offsetY;
    if (window.tool === "pencil" || window.tool === "eraser") {
      if (window.tool === "pencil") {
        width = 3;
        context.globalCompositeOperation = "source-over";
      } else if (window.tool === "eraser") {
        width = 10;
        context.globalCompositeOperation = "destination-out";
      }
      switch (e.type) {
        case "mousedown":
          drawing = true;
          context.fillStyle = color;
          context.strokeStyle = color;
          context.beginPath();
          context.arc(x, y, Math.round(width / 2), 0, 2 * Math.PI, false);
          context.fill();
          context.beginPath();
          context.lineCap = "round";
          return context.moveTo(x, y);
        case "mousemove":
          if (drawing === true) {
            context.lineTo(x, y);
            context.lineWidth = width;
            return context.stroke();
          }
          break;
        case "mouseup":
          return drawing = false;
      }
    } else if (window.tool === "dropper") {
      switch (e.type) {
        case "mousedown":
          drop = true;
          pixel = context.getImageData(x, y, 1, 1).data;
          return color_select.color.fromRGB(pixel[0] / 255, pixel[1] / 255, pixel[2] / 255);
        case "mouseup":
          return drop = false;
        case "mousemove":
          if (drop === true) {
            pixel = context.getImageData(x, y, 1, 1).data;
            return color_select.color.fromRGB(pixel[0] / 255, pixel[1] / 255, pixel[2] / 255);
          }
      }
    } else if (window.tool === "fill") {
      if (e.type === "mouseup") {
        pixelStack = [];
        fillColor = color_select.color.rgb.map(function(value) {
          return Math.round(value * 255);
        });
        fillColor.push(255);
        data = context.getImageData(0, 0, 640, 400);
        pixels = data.data;
        originalPos = (y * 640 + x) * 4;
        originalPix = '';
        for (i = _i = 0; _i <= 3; i = ++_i) {
          originalPix += pixels[originalPos + i];
        }
        pixelStack.push([x, y]);
        while (pixelStack.length > 0) {
          coord = pixelStack.pop();
          px = coord[0];
          py = coord[1];
          scanPos = ((py--) * 640 + px) * 4;
          while (comparePix(originalPix, scanPos, pixels) && py > 0) {
            scanPos = ((py--) * 640 + px) * 4;
            rightPos = (py * 640 + px + 2) * 4;
            leftPos = (py * 640 + px - 2) * 4;
            if (comparePix(originalPix, rightPos, pixels) && px < 640) {
              console.log("left push");
              pixelStack.push([px + 1, py]);
            }
            if (comparePix(originalPix, leftPos, pixels) && px > 0) {
              pixelStack.push([px - 1, py]);
              console.log("right push");
            }
          }
          paintPos = (py += 1 * 640 + px) * 4;
          while (comparePix(originalPix, paintPos, pixels) && py < 400) {
            for (i = _j = 0; _j <= 3; i = ++_j) {
              pixels[paintPos + i] = fillColor[i];
            }
            paintPos = (py++ * 640 + px) * 4;
          }
        }
        return context.putImageData(data, 0, 0);
      }
    }
  };

  comparePix = function(originalPix, pixPosB, pixels) {
    var i, pixB, _i;
    pixB = '';
    for (i = _i = 0; _i <= 3; i = ++_i) {
      pixB += pixels[pixPosB + i].toString();
    }
    if (originalPix === pixB) {
      return true;
    } else {
      return false;
    }
  };

  window.initTools = function() {
    var tool, tools, _i, _len, _results;
    tools = document.getElementsByClassName("tool");
    _results = [];
    for (_i = 0, _len = tools.length; _i < _len; _i++) {
      tool = tools[_i];
      _results.push(tool.addEventListener("click", function(e) {
        if (this.id === "clear") {
          return window.clearCanvas("draw");
        } else {
          return window.tool = this.id;
        }
      }));
    }
    return _results;
  };

}).call(this);
